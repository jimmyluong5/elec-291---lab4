#include <EFM8LB1.h>
#include <stdio.h>

#define SYSCLK   24500000L
#define BAUDRATE 115200L

#define LCD_RS P1_7
#define LCD_E  P2_0
#define LCD_D4 P1_3
#define LCD_D5 P1_2
#define LCD_D6 P1_1
#define LCD_D7 P1_0
#define CHARS_PER_LINE 16

#define unitbutton      P2_1
#define voltageread     P2_2
#define resistorbutton  P2_3

#define cap_mode 0
#define resistor_mode 1

// ADC open/short thresholds (12-bit ADC: 0..4095)
#define OPEN_THRESHOLD   4080U
#define SHORT_THRESHOLD  5U

// Scale by ~1.17 for "resistance mode" output (per your request)
#define SCALE_NUM 117UL
#define SCALE_DEN 100UL

// Capacitance unit modes
#define CAP_UNIT_NF 0
#define CAP_UNIT_UF 1
#define CAP_UNIT_PF 2

unsigned char current_mode = cap_mode;
unsigned char overflow_count;

// capacitance unit cycling state
unsigned char cap_unit_mode = CAP_UNIT_NF;
unsigned char prev_unitbutton = 1;

char _c51_external_startup (void)
{
	SFRPAGE = 0x00;
	WDTCN = 0xDE;
	WDTCN = 0xAD;

	VDM0CN |= 0x80;
	RSTSRC = 0x02;

	CLKSEL = 0x00;
	CLKSEL = 0x00;
	while ((CLKSEL & 0x80) == 0);

	P0MDOUT |= 0x10; // UART0 TX push-pull

	// P2.1/P2.2/P2.3 inputs
	P2MDOUT &= ~0x0E;
	P2      |= 0x0E;     // weak pullups (buttons)
	P2SKIP  |= 0x0E;

	// P2.2 analog input:
	P2MDIN  &= ~(1<<2);

	XBR0     = 0x01;    // UART0
	XBR1     = 0x10;    // T0 on P0.0
	XBR2     = 0x40;    // enable crossbar

	// UART0 using Timer1
	SCON0 = 0x10;
	CKCON0 |= 0b_0000_0000; // Timer1 uses SYSCLK/12
	TH1 = 0x100 - ((SYSCLK/BAUDRATE)/(2L*12L));
	TL1 = TH1;
	TMOD &= ~0xF0;
	TMOD |=  0x20;
	TR1 = 1;
	TI  = 1;

	return 0;
}

void Timer3us(unsigned char us)
{
	unsigned char i;
	CKCON0 |= 0b_0100_0000; // Timer3 uses SYSCLK

	TMR3RL = (-(SYSCLK)/1000000L);
	TMR3   = TMR3RL;

	TMR3CN0 = 0x04;
	for (i = 0; i < us; i++)
	{
		while (!(TMR3CN0 & 0x80));
		TMR3CN0 &= ~(0x80);

		// Count Timer0 overflows while we wait (for frequency measurement)
		if (TF0)
		{
			TF0 = 0;
			overflow_count++;
		}
	}
	TMR3CN0 = 0;
}

void waitms (unsigned int ms)
{
	unsigned int j;
	for (j = ms; j != 0; j--)
	{
		Timer3us(249);
		Timer3us(249);
		Timer3us(249);
		Timer3us(250);
	}
}

void TIMER0_Init(void)
{
	TMOD &= 0b_1111_0000;
	TMOD |= 0b_0000_0101; // Timer0 as 16-bit counter (external T0 pin)
	TR0 = 0;
}

// LCD helpers
void LCD_pulse (void)
{
	LCD_E = 1;
	Timer3us(40);
	LCD_E = 0;
}

void LCD_byte (unsigned char x)
{
	ACC = x;
	LCD_D7 = ACC_7;
	LCD_D6 = ACC_6;
	LCD_D5 = ACC_5;
	LCD_D4 = ACC_4;
	LCD_pulse();
	Timer3us(40);

	ACC = x;
	LCD_D7 = ACC_3;
	LCD_D6 = ACC_2;
	LCD_D5 = ACC_1;
	LCD_D4 = ACC_0;
	LCD_pulse();
}

void WriteData (unsigned char x)
{
	LCD_RS = 1;
	LCD_byte(x);
	waitms(2);
}

void WriteCommand (unsigned char x)
{
	LCD_RS = 0;
	LCD_byte(x);
	waitms(5);
}

void LCD_4BIT (void)
{
	LCD_E = 0;
	waitms(20);

	WriteCommand(0x33);
	WriteCommand(0x33);
	WriteCommand(0x32);

	WriteCommand(0x28);
	WriteCommand(0x0c);
	WriteCommand(0x01);
	waitms(20);
}

void LCDprint(char * string, unsigned char line, bit clear)
{
	int j;
	WriteCommand(line == 2 ? 0xC0 : 0x80);
	waitms(5);

	for (j = 0; string[j] != 0; j++) WriteData(string[j]);
	if (clear) for (; j < CHARS_PER_LINE; j++) WriteData(' ');
}

// ===== ADC =====
void InitADC (void)
{
	SFRPAGE = 0x00;

	ADC0CN0 = 0x80;   // enable ADC0
	ADC0CF0 = 0x20;
	ADC0CF1 = 0x00;
	REF0CN  = 0x18;   // VDD reference
}

unsigned int ReadADC (unsigned char channel)
{
	unsigned int v;
	SFRPAGE = 0x00;
	ADC0MX = channel;

	ADC0CN0 &= ~0x20;              // clear ADINT
	ADC0CN0 |=  0x10;              // start conversion
	while ((ADC0CN0 & 0x20) == 0); // wait ADINT

	v = ((unsigned int)ADC0H << 8) | ADC0L;
	return (v & 0x0FFF);           // 12-bit (0..4095)
}

void main (void)
{
	unsigned long F;
	unsigned long cap_nf;
	unsigned long cap_pf;
	unsigned long uf_int, uf_dec;

	unsigned long scaled;
	unsigned int adc_result;

	char buf[16];

	TIMER0_Init();
	InitADC();

	waitms(200);
	LCD_4BIT();

	while (1)
	{
		// --- unitbutton edge detect (P2.1) ---
		if ((prev_unitbutton == 1) && (unitbutton == 0))
		{
			waitms(20);
			if (unitbutton == 0)
			{
				if (current_mode != cap_mode)
				{
					current_mode = cap_mode;
				}
				else
				{
					// cycle nF -> uF -> pF
					if (cap_unit_mode == CAP_UNIT_NF) cap_unit_mode = CAP_UNIT_UF;
					else if (cap_unit_mode == CAP_UNIT_UF) cap_unit_mode = CAP_UNIT_PF;
					else cap_unit_mode = CAP_UNIT_NF;
				}
				while (unitbutton == 0) {;}
				waitms(20);
			}
		}
		prev_unitbutton = unitbutton;

		// --- resistorbutton (P2.3) ---
		if (resistorbutton == 0)
		{
			waitms(20);
			if (resistorbutton == 0)
			{
				current_mode = resistor_mode;
				while (resistorbutton == 0) {;}
				waitms(20);
			}
		}

		// --- modes ---
		if (current_mode == cap_mode)
		{
			LCDprint("Capacitance:", 1, 1);

			TL0 = 0;
			TH0 = 0;
			overflow_count = 0;
			TF0 = 0;

			TR0 = 1;
			waitms(1000);
			TR0 = 0;

			F = overflow_count * 0x10000L + TH0 * 0x100L + TL0;

			if (F == 0) cap_nf = 0;
			else cap_nf = (unsigned long)(1440000 / (5.0 * F)); // your original style

			if (cap_unit_mode == CAP_UNIT_NF)
			{
				sprintf(buf, "%lunF", cap_nf);
			}
			else if (cap_unit_mode == CAP_UNIT_PF)
			{
				cap_pf = cap_nf * 1000UL;
				sprintf(buf, "%lupF", cap_pf);
			}
			else // uF with decimals
			{
				uf_int = cap_nf / 1000UL;
				uf_dec = cap_nf % 1000UL;
				sprintf(buf, "%lu.%03luuF", uf_int, uf_dec);
			}

			LCDprint(buf, 2, 1);
		}
		else
		{
			LCDprint("Resistance:", 1, 1);

			adc_result = ReadADC(0x0F); // P2.2

			if (adc_result >= OPEN_THRESHOLD || adc_result <= SHORT_THRESHOLD)
			{
				scaled = 0;
			}
			else
			{
				// scaled = adc * 1.17 (rounded)
				scaled = ((unsigned long)adc_result * SCALE_NUM + (SCALE_DEN/2)) / SCALE_DEN;
			}

			sprintf(buf, "%lu", scaled);
			LCDprint(buf, 2, 1);
		}

		waitms(120);
	}
}
