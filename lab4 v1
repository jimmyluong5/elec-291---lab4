// lab4.c: Frequency on T0 and "Resistance" mode shows (ADC reading * 1.17)
// Per request: do NOT compute resistance from voltage divider anymore.
// Uses 12-bit ADC reading from P2.2 (0..4095), then scales by 1.17 using integer math.
//
// Scaling: scaled = adc * 117 / 100  (Ëœ1.17) with rounding.

#include <EFM8LB1.h>
#include <stdio.h>

#define SYSCLK   24500000L
#define BAUDRATE 115200L

#define LCD_RS P1_7
// #define LCD_RW Px_x // Not used. Connect to GND
#define LCD_E  P2_0
#define LCD_D4 P1_3
#define LCD_D5 P1_2
#define LCD_D6 P1_1
#define LCD_D7 P1_0
#define CHARS_PER_LINE 16

#define unitbutton      P2_1
#define voltageread     P2_2
#define resistorbutton  P2_3

#define cap_mode 0
#define resistor_mode 1

// If P2.2 is floating/open it tends to read full-scale; show 0 like you wanted
#define OPEN_THRESHOLD   4080U
#define SHORT_THRESHOLD  5U

// Scale by ~1.17
#define SCALE_NUM 117UL
#define SCALE_DEN 100UL

unsigned char current_mode = cap_mode;
unsigned char overflow_count;

char _c51_external_startup (void)
{
	SFRPAGE = 0x00;
	WDTCN = 0xDE;
	WDTCN = 0xAD;

	VDM0CN |= 0x80;
	RSTSRC = 0x02;

	// 24.5 MHz
	CLKSEL = 0x00;
	CLKSEL = 0x00;
	while ((CLKSEL & 0x80) == 0);

	P0MDOUT |= 0x10; // UART0 TX push-pull

	// P2.1/P2.2/P2.3 inputs
	P2MDOUT &= ~0x0E;
	P2      |= 0x0E;     // weak pullups (buttons)
	P2SKIP  |= 0x0E;

	// P2.2 analog input:
	P2MDIN  &= ~(1<<2);

	XBR0     = 0x01;    // UART0
	XBR1     = 0x10;    // T0
	XBR2     = 0x40;    // enable crossbar

	// UART0 using Timer1
	SCON0 = 0x10;
	CKCON0 |= 0b_0000_0000; // Timer1 uses SYSCLK/12
	TH1 = 0x100 - ((SYSCLK/BAUDRATE)/(2L*12L));
	TL1 = TH1;
	TMOD &= ~0xF0;
	TMOD |=  0x20;
	TR1 = 1;
	TI  = 1;

	return 0;
}

void Timer3us(unsigned char us)
{
	unsigned char i;
	CKCON0 |= 0b_0100_0000; // Timer3 uses SYSCLK

	TMR3RL = (-(SYSCLK)/1000000L);
	TMR3   = TMR3RL;

	TMR3CN0 = 0x04;
	for (i = 0; i < us; i++)
	{
		while (!(TMR3CN0 & 0x80));
		TMR3CN0 &= ~(0x80);

		if (TF0)
		{
			TF0 = 0;
			overflow_count++;
		}
	}
	TMR3CN0 = 0;
}

void waitms (unsigned int ms)
{
	unsigned int j;
	for (j = ms; j != 0; j--)
	{
		Timer3us(249);
		Timer3us(249);
		Timer3us(249);
		Timer3us(250);
	}
}

void TIMER0_Init(void)
{
	TMOD &= 0b_1111_0000;
	TMOD |= 0b_0000_0101; // Timer0 as 16-bit counter (external T0 pin)
	TR0 = 0;
}

// LCD helpers
void LCD_pulse (void)
{
	LCD_E = 1;
	Timer3us(40);
	LCD_E = 0;
}

void LCD_byte (unsigned char x)
{
	ACC = x;
	LCD_D7 = ACC_7;
	LCD_D6 = ACC_6;
	LCD_D5 = ACC_5;
	LCD_D4 = ACC_4;
	LCD_pulse();
	Timer3us(40);

	ACC = x;
	LCD_D7 = ACC_3;
	LCD_D6 = ACC_2;
	LCD_D5 = ACC_1;
	LCD_D4 = ACC_0;
	LCD_pulse();
}

void WriteData (unsigned char x)
{
	LCD_RS = 1;
	LCD_byte(x);
	waitms(2);
}

void WriteCommand (unsigned char x)
{
	LCD_RS = 0;
	LCD_byte(x);
	waitms(5);
}

void LCD_4BIT (void)
{
	LCD_E = 0;
	waitms(20);

	WriteCommand(0x33);
	WriteCommand(0x33);
	WriteCommand(0x32);

	WriteCommand(0x28);
	WriteCommand(0x0c);
	WriteCommand(0x01);
	waitms(20);
}

void LCDprint(char * string, unsigned char line, bit clear)
{
	int j;
	WriteCommand(line == 2 ? 0xC0 : 0x80);
	waitms(5);

	for (j = 0; string[j] != 0; j++) WriteData(string[j]);
	if (clear) for (; j < CHARS_PER_LINE; j++) WriteData(' ');
}

// ===== ADC =====
void InitADC (void)
{
	SFRPAGE = 0x00;

	ADC0CN0 = 0x80;   // enable ADC0
	ADC0CF0 = 0x20;
	ADC0CF1 = 0x00;
	REF0CN  = 0x18;   // VDD reference
}

unsigned int ReadADC (unsigned char channel)
{
	unsigned int v;
	SFRPAGE = 0x00;
	ADC0MX = channel;

	ADC0CN0 &= ~0x20;              // clear ADINT
	ADC0CN0 |=  0x10;              // start conversion
	while ((ADC0CN0 & 0x20) == 0); // wait ADINT

	v = ((unsigned int)ADC0H << 8) | ADC0L;
	return (v & 0x0FFF);           // 12-bit (0..4095)
}

void main (void)
{
	unsigned long F;
	unsigned long cap;
	unsigned long scaled;
	unsigned int adc_result;
	char buf[16];

	TIMER0_Init();
	InitADC();

	waitms(200);
	LCD_4BIT();

	while (1)
	{
		if (unitbutton == 0)
		{
			current_mode = cap_mode;
			waitms(5);
		}

		if (resistorbutton == 0)
		{
			current_mode = resistor_mode;
			waitms(5);
		}

		if (current_mode == cap_mode)
		{
			LCDprint("Capacitance:", 1, 1);

			TL0 = 0;
			TH0 = 0;
			overflow_count = 0;
			TF0 = 0;

			TR0 = 1;
			waitms(1000);
			TR0 = 0;

			F = overflow_count * 0x10000L + TH0 * 0x100L + TL0;
			cap = 1440000 / (5.0 * F); // kept as-is

			sprintf(buf, "%lunF", cap);
			LCDprint(buf, 2, 1);
		}
		else
		{
			LCDprint("Resistance:", 1, 1);

			adc_result = ReadADC(0x0F); // P2.2

			// If open or near-short, show 0 (your earlier requirement)
			if (adc_result >= OPEN_THRESHOLD || adc_result <= SHORT_THRESHOLD)
			{
				scaled = 0;
			}
			else
			{
				// scaled = adc * 1.17 (rounded)
				scaled = ((unsigned long)adc_result * SCALE_NUM + (SCALE_DEN/2)) / SCALE_DEN;
			}

			sprintf(buf, "%lu", scaled);
			LCDprint(buf, 2, 1);
		}

		waitms(150);
	}
}
